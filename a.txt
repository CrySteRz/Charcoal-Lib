#![feature(prelude_import)]
//! Charcoal is a client-library for Hearth that makes it easy to use Hearth with Rust.
//! See Examples in the Github repo [here](https://github.com/Hearth-Industries/Charcoal/tree/main/examples)
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::collections::HashMap;
use std::sync::Arc;
use kafka::consumer::Consumer;
use kafka::producer::Producer;
use lazy_static::lazy_static;
use tokio::sync::{broadcast, Mutex};
use tokio::sync::broadcast::{Receiver, Sender};
use crate::background::processor::{init_processor, IPCData};
use crate::connector::{initialize_client, initialize_producer};
mod connector {
    use std::process;
    use std::time::Duration;
    use hearth_interconnect::messages::Message;
    use kafka;
    use kafka::consumer::Consumer;
    use kafka::producer::{Producer, Record, RequiredAcks};
    use log::{debug, error, info, warn};
    use openssl;
    use tokio::sync::broadcast::Receiver;
    use tokio::time::sleep;
    use crate::background::processor::IPCData;
    use crate::CharcoalConfig;
    use self::kafka::client::{FetchOffset, KafkaClient, SecurityConfig};
    use self::openssl::ssl::{SslConnector, SslFiletype, SslMethod, SslVerifyMode};
    pub fn initialize_client(
        brokers: &Vec<String>,
        config: &CharcoalConfig,
    ) -> KafkaClient {
        let mut client: KafkaClient;
        if config.ssl.is_some() {
            let mut builder = SslConnector::builder(SslMethod::tls()).unwrap();
            builder.set_cipher_list("DEFAULT").unwrap();
            builder.set_verify(SslVerifyMode::PEER);
            let cert_file = config.ssl.as_ref().unwrap().ssl_cert.clone();
            let cert_key = config.ssl.as_ref().unwrap().ssl_key.clone();
            let ca_cert = config.ssl.as_ref().unwrap().ssl_ca.clone();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        format_args!(
                            "loading cert-file={0}, key-file={1}", cert_file, cert_key
                        ),
                        lvl,
                        &(
                            "charcoal::connector",
                            "charcoal::connector",
                            "src/connector.rs",
                            38u32,
                        ),
                        ::log::__private_api::Option::None,
                    );
                }
            };
            builder.set_certificate_file(cert_file, SslFiletype::PEM).unwrap();
            builder.set_private_key_file(cert_key, SslFiletype::PEM).unwrap();
            builder.check_private_key().unwrap();
            builder.set_ca_file(ca_cert).unwrap();
            let connector = builder.build();
            client = KafkaClient::new_secure(
                brokers.to_owned(),
                SecurityConfig::new(connector),
            );
        } else {
            client = KafkaClient::new(brokers.to_owned());
        }
        match client.load_metadata_all() {
            Err(e) => {
                {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api_log(
                            format_args!("{0:?}", e),
                            lvl,
                            &(
                                "charcoal::connector",
                                "charcoal::connector",
                                "src/connector.rs",
                                64u32,
                            ),
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                drop(client);
                process::exit(1);
            }
            Ok(_) => {}
        }
        return client;
    }
    pub fn initialize_producer(client: KafkaClient) -> Producer {
        let producer = Producer::from_client(client)
            .with_ack_timeout(Duration::from_secs(1))
            .with_required_acks(RequiredAcks::One)
            .create()
            .unwrap();
        return producer;
    }
    pub fn send_message(message: &Message, topic: &str, producer: &mut Producer) {
        let data = serde_json::to_string(message).unwrap();
        producer.send(&Record::from_value(topic, data)).unwrap();
    }
    pub async fn boilerplate_parse_ipc<T>(mut ipc_parser: T, mut rx: Receiver<IPCData>)
    where
        T: FnMut(IPCData) -> bool,
    {
        let mut run = true;
        while run {
            let rxm = rx.try_recv();
            match rxm {
                Ok(m) => {
                    run = ipc_parser(m);
                }
                Err(e) => {
                    {
                        let lvl = ::log::Level::Error;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!("{0}", e),
                                lvl,
                                &(
                                    "charcoal::connector",
                                    "charcoal::connector",
                                    "src/connector.rs",
                                    102u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                }
            }
            sleep(Duration::from_millis(150)).await;
        }
    }
}
pub mod actions {
    //! Actions that can be used to interact with a Hearth server
    /// Provides basic functionality to create a job on the hearth server, join a channel, and exit a channel
    pub mod channel_manager {
        use std::sync::{Arc, Mutex};
        use std::time::Duration;
        use hearth_interconnect::messages::{JobRequest, Message};
        use hearth_interconnect::worker_communication::{
            DirectWorkerCommunication, DWCActionType,
        };
        use log::{debug, error};
        use nanoid::nanoid;
        use crate::{CONSUMER, PlayerObject, PRODUCER};
        use async_trait::async_trait;
        use hearth_interconnect::errors::ErrorReport;
        use tokio::time::sleep;
        use crate::background::processor::IPCData;
        use crate::connector::{boilerplate_parse_ipc, send_message};
        /// Provides basic functionality to create a job on the hearth server, join a channel, and exit a channel
        pub trait ChannelManager {
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn create_job<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn join_channel<'life0, 'async_trait>(
                &'life0 mut self,
                voice_channel_id: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn exit_channel<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
        }
        impl ChannelManager for PlayerObject {
            /// Create job on Hearth server for this PlayerObject
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn create_job<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let mut __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::ExternalQueueJob(JobRequest {
                                        request_id: ::nanoid::format(
                                            ::nanoid::rngs::default,
                                            &::nanoid::alphabet::SAFE,
                                            21,
                                        ),
                                        guild_id: __self.guild_id.clone(),
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                        boilerplate_parse_ipc(
                                |msg| {
                                    if let IPCData::FromBackground(bg) = msg {
                                        if let Message::ExternalQueueJobResponse(q) = bg.message {
                                            __self.job_id = Some(q.job_id);
                                            __self.worker_id = Some(q.worker_id);
                                            return false;
                                        }
                                    }
                                    return true;
                                },
                                __self.tx.subscribe(),
                            )
                            .await;
                    };
                })
            }
            /// Join Voice Channel
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn join_channel<'life0, 'async_trait>(
                &'life0 mut self,
                voice_channel_id: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let mut __self = self;
                    let voice_channel_id = voice_channel_id;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        guild_id: Some(__self.guild_id.clone()),
                                        voice_channel_id: Some(voice_channel_id),
                                        play_audio_url: None,
                                        action_type: DWCActionType::JoinChannel,
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            /// Exit voice channel
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn exit_channel<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::LeaveChannel,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
        }
    }
    /// Allows you to start playback using an HttpRequest or from a Youtube URL
    pub mod player {
        use async_trait::async_trait;
        use hearth_interconnect::messages::Message;
        use hearth_interconnect::worker_communication::{
            DirectWorkerCommunication, DWCActionType,
        };
        use nanoid::nanoid;
        use crate::{PlayerObject, PRODUCER};
        use crate::background::processor::IPCData;
        use crate::connector::send_message;
        /// Allows you to start playback using an HttpRequest or from a Youtube URL
        pub trait Player {
            /// Play from an HTTP URL
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn play_from_http<'life0, 'async_trait>(
                &'life0 mut self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Play from a Youtube URL
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn play_from_youtube<'life0, 'async_trait>(
                &'life0 mut self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
        }
        impl Player for PlayerObject {
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn play_from_http<'life0, 'async_trait>(
                &'life0 mut self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let mut __self = self;
                    let url = url;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::PlayDirectLink,
                                        play_audio_url: Some(url),
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn play_from_youtube<'life0, 'async_trait>(
                &'life0 mut self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let mut __self = self;
                    let url = url;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::PlayFromYoutube,
                                        play_audio_url: Some(url),
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
        }
    }
    /// Provides functionality that can be used once you start playing a track such as: looping, pausing, and resuming.
    pub mod track_manager {
        use std::time::Duration;
        use async_trait::async_trait;
        use hearth_interconnect::messages::{Message, Metadata};
        use hearth_interconnect::worker_communication::{
            DirectWorkerCommunication, DWCActionType,
        };
        use log::{debug, error};
        use nanoid::nanoid;
        use tokio::time::sleep;
        use crate::{CONSUMER, PlayerObject, PRODUCER};
        use crate::background::processor::IPCData;
        use crate::connector::{boilerplate_parse_ipc, send_message};
        /// Provides functionality that can be used once you start playing a track such as: looping, pausing, and resuming.
        pub trait TrackManager {
            /// Set playback volume
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn set_playback_volume<'life0, 'async_trait>(
                &'life0 self,
                playback_volume: f32,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Stop looping
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn force_stop_loop<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Loop forever
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn loop_indefinitely<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Loop X amount of times
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn loop_x_times<'life0, 'async_trait>(
                &'life0 self,
                times: usize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Seek to position on track from start
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn seek_to_position<'life0, 'async_trait>(
                &'life0 self,
                position: Duration,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Resume playback
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn resume_playback<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Pause playback
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn pause_playback<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Get metadata for track currently being played
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn get_metadata<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Metadata,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
        }
        impl TrackManager for PlayerObject {
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn set_playback_volume<'life0, 'async_trait>(
                &'life0 self,
                playback_volume: f32,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let playback_volume = playback_volume;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::SetPlaybackVolume,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: Some(playback_volume),
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn force_stop_loop<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::ForceStopLoop,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn loop_indefinitely<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::LoopForever,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn loop_x_times<'life0, 'async_trait>(
                &'life0 self,
                times: usize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let times = times;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::LoopXTimes,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: Some(times.clone()),
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn seek_to_position<'life0, 'async_trait>(
                &'life0 self,
                position: Duration,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let position = position;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::SeekToPosition,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: Some(position.as_millis() as u64),
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn resume_playback<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::ResumePlayback,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn pause_playback<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = (),
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __self = self;
                    let _: () = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::PausePlayback,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                    };
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_metadata<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Metadata,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Metadata> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Metadata = {
                        __self
                            .bg_com_tx
                            .send(
                                IPCData::new_from_main(
                                    Message::DirectWorkerCommunication(DirectWorkerCommunication {
                                        job_id: __self.job_id.clone().unwrap(),
                                        action_type: DWCActionType::GetMetaData,
                                        play_audio_url: None,
                                        guild_id: Some(__self.guild_id.clone()),
                                        request_id: Some(
                                            ::nanoid::format(
                                                ::nanoid::rngs::default,
                                                &::nanoid::alphabet::SAFE,
                                                21,
                                            ),
                                        ),
                                        new_volume: None,
                                        seek_position: None,
                                        loop_times: None,
                                        worker_id: __self.worker_id.clone().unwrap(),
                                        voice_channel_id: None,
                                    }),
                                    __self.tx.clone(),
                                    __self.guild_id.clone(),
                                ),
                            )
                            .unwrap();
                        let mut result: Option<Metadata> = None;
                        boilerplate_parse_ipc(
                                |msg| {
                                    if let IPCData::FromBackground(bg) = msg {
                                        if let Message::ExternalMetadataResult(m) = bg.message {
                                            result = Some(m);
                                            return false;
                                        }
                                    }
                                    return true;
                                },
                                __self.tx.subscribe(),
                            )
                            .await;
                        return result.unwrap();
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub mod standard {
        //! Standard actions that can be called on a PlayerObject
        use std::sync::Arc;
        use std::time::Duration;
        use async_fn_traits::{AsyncFn2, AsyncFn3};
        use hearth_interconnect::errors::ErrorReport;
        use log::error;
        use serenity::http::Http;
        use tokio::time::sleep;
        use crate::background::processor::IPCData;
        use crate::PlayerObject;
        impl PlayerObject {
            /// Register an error callback that will be called if an error occurs on this PlayerObject
            pub async fn register_error_callback<
                A: AsyncFn3<ErrorReport, Arc<Http>, String, Output = ()>
                    + std::marker::Send + 'static + std::marker::Sync + Send + Sync,
            >(&mut self, callback: A, http: Arc<Http>, channel_id: String)
            where
                <A as AsyncFn3<
                    hearth_interconnect::errors::ErrorReport,
                    Arc<serenity::http::Http>,
                    std::string::String,
                >>::OutputFuture: std::marker::Send,
            {
                let mut t_rx = self.tx.subscribe();
                let guild_id = self.guild_id.clone();
                tokio::spawn(async move {
                    loop {
                        let x = t_rx.try_recv();
                        match x {
                            Ok(d) => {
                                match d {
                                    IPCData::ErrorReport(e) => {
                                        {
                                            ::std::io::_print(format_args!("ERX: {0:?}\n", e.clone()));
                                        };
                                        {
                                            ::std::io::_print(
                                                format_args!(
                                                    "ERXM: {0},{1}\n", guild_id, e.guild_id.clone()
                                                ),
                                            );
                                        };
                                        if guild_id == e.guild_id {
                                            {
                                                ::std::io::_print(format_args!("ERX-REG-CALLBACK\n"));
                                            };
                                            callback(e, http.clone(), channel_id.clone()).await;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            Err(e) => {
                                if e.to_string() != "channel empty".to_string() {
                                    {
                                        let lvl = ::log::Level::Error;
                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                            && lvl <= ::log::max_level()
                                        {
                                            ::log::__private_api_log(
                                                format_args!("Failed to RECV with error: {0:?}", e),
                                                lvl,
                                                &(
                                                    "charcoal::actions::standard",
                                                    "charcoal::actions::standard",
                                                    "src/actions/standard.rs",
                                                    38u32,
                                                ),
                                                ::log::__private_api::Option::None,
                                            );
                                        }
                                    };
                                }
                            }
                        }
                        sleep(Duration::from_millis(250)).await;
                    }
                });
            }
        }
    }
}
pub mod serenity {
    //! Provides ClientBuilder extension for super easy use with serenity
    use std::sync::Arc;
    use futures::executor;
    use serenity::prelude::TypeMapKey;
    use crate::{Charcoal, CharcoalConfig, init_charcoal};
    use serenity::*;
    pub use serenity::client::ClientBuilder;
    use tokio::sync::Mutex;
    pub struct CharcoalKey;
    impl TypeMapKey for CharcoalKey {
        type Value = Arc<Mutex<Charcoal>>;
    }
    pub trait SerenityInit {
        #[must_use]
        /// Initializes charcoal and registers it in the Serenity type-map
        fn register_charcoal(self, broker: String, config: CharcoalConfig) -> Self;
    }
    impl SerenityInit for ClientBuilder {
        fn register_charcoal(self, broker: String, config: CharcoalConfig) -> Self {
            let c = init_charcoal(broker, config);
            self.type_map_insert::<CharcoalKey>(executor::block_on(c))
        }
    }
}
pub mod background {
    pub mod processor {
        use std::collections::HashMap;
        use std::sync::Arc;
        use hearth_interconnect::errors::ErrorReport;
        use hearth_interconnect::messages::Message;
        use kafka::consumer::Consumer;
        use kafka::producer::Producer;
        use log::{debug, error};
        use nanoid::nanoid;
        use tokio::sync::broadcast::{Receiver, Sender};
        use crate::connector::send_message;
        pub struct FromBackgroundData {
            pub message: Message,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FromBackgroundData {
            #[inline]
            fn clone(&self) -> FromBackgroundData {
                FromBackgroundData {
                    message: ::core::clone::Clone::clone(&self.message),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FromBackgroundData {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "FromBackgroundData",
                    "message",
                    &&self.message,
                )
            }
        }
        pub struct FromMainData {
            pub message: Message,
            pub response_tx: Arc<Sender<IPCData>>,
            pub guild_id: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FromMainData {
            #[inline]
            fn clone(&self) -> FromMainData {
                FromMainData {
                    message: ::core::clone::Clone::clone(&self.message),
                    response_tx: ::core::clone::Clone::clone(&self.response_tx),
                    guild_id: ::core::clone::Clone::clone(&self.guild_id),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FromMainData {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "FromMainData",
                    "message",
                    &self.message,
                    "response_tx",
                    &self.response_tx,
                    "guild_id",
                    &&self.guild_id,
                )
            }
        }
        pub enum IPCData {
            FromBackground(FromBackgroundData),
            FromMain(FromMainData),
            ErrorReport(ErrorReport),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IPCData {
            #[inline]
            fn clone(&self) -> IPCData {
                match self {
                    IPCData::FromBackground(__self_0) => {
                        IPCData::FromBackground(::core::clone::Clone::clone(__self_0))
                    }
                    IPCData::FromMain(__self_0) => {
                        IPCData::FromMain(::core::clone::Clone::clone(__self_0))
                    }
                    IPCData::ErrorReport(__self_0) => {
                        IPCData::ErrorReport(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for IPCData {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    IPCData::FromBackground(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FromBackground",
                            &__self_0,
                        )
                    }
                    IPCData::FromMain(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "FromMain",
                            &__self_0,
                        )
                    }
                    IPCData::ErrorReport(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ErrorReport",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl IPCData {
            pub fn new_from_main(
                message: Message,
                sender: Arc<Sender<IPCData>>,
                guild_id: String,
            ) -> IPCData {
                IPCData::FromMain(FromMainData {
                    message,
                    response_tx: sender,
                    guild_id,
                })
            }
            pub fn new_from_background(message: Message) -> IPCData {
                IPCData::FromBackground(FromBackgroundData { message })
            }
        }
        pub async fn init_processor(
            mut rx: Receiver<IPCData>,
            mut global_tx: Sender<IPCData>,
            mut consumer: Consumer,
            mut producer: Producer,
        ) {
            let mut guild_id_to_tx: HashMap<String, Arc<Sender<IPCData>>> = HashMap::new();
            loop {
                let mss = consumer.poll().unwrap();
                if mss.is_empty() {
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api_log(
                                format_args!("No messages available right now."),
                                lvl,
                                &(
                                    "charcoal::background::processor",
                                    "charcoal::background::processor",
                                    "src/background/processor.rs",
                                    53u32,
                                ),
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                }
                for ms in mss.iter() {
                    for m in ms.messages() {
                        let parsed_message: Result<Message, serde_json::Error> = serde_json::from_slice(
                            m.value,
                        );
                        match parsed_message {
                            Ok(message) => {
                                match &message {
                                    Message::ErrorReport(e) => {
                                        {
                                            let lvl = ::log::Level::Error;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                ::log::__private_api_log(
                                                    format_args!("GOT Error: {0:?} From Hearth Server", e),
                                                    lvl,
                                                    &(
                                                        "charcoal::background::processor",
                                                        "charcoal::background::processor",
                                                        "src/background/processor.rs",
                                                        63u32,
                                                    ),
                                                    ::log::__private_api::Option::None,
                                                );
                                            }
                                        };
                                        let tx = guild_id_to_tx.get_mut(&e.guild_id);
                                        match tx {
                                            Some(tx) => {
                                                let gt = tx.send(IPCData::ErrorReport(e.clone()));
                                                match gt {
                                                    Ok(_) => {}
                                                    Err(e) => {
                                                        {
                                                            let lvl = ::log::Level::Error;
                                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                                && lvl <= ::log::max_level()
                                                            {
                                                                ::log::__private_api_log(
                                                                    format_args!(
                                                                        "Failed to send error report with error: {0:?}", e
                                                                    ),
                                                                    lvl,
                                                                    &(
                                                                        "charcoal::background::processor",
                                                                        "charcoal::background::processor",
                                                                        "src/background/processor.rs",
                                                                        71u32,
                                                                    ),
                                                                    ::log::__private_api::Option::None,
                                                                );
                                                            }
                                                        };
                                                    }
                                                }
                                            }
                                            None => {
                                                let lvl = ::log::Level::Error;
                                                if lvl <= ::log::STATIC_MAX_LEVEL
                                                    && lvl <= ::log::max_level()
                                                {
                                                    ::log::__private_api_log(
                                                        format_args!(
                                                            "Failed to get appropriate sender when attempting to send error report"
                                                        ),
                                                        lvl,
                                                        &(
                                                            "charcoal::background::processor",
                                                            "charcoal::background::processor",
                                                            "src/background/processor.rs",
                                                            76u32,
                                                        ),
                                                        ::log::__private_api::Option::None,
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    Message::ExternalQueueJobResponse(r) => {
                                        let tx = guild_id_to_tx.get_mut(&r.guild_id);
                                        match tx {
                                            Some(tx) => {
                                                let r = tx.send(IPCData::new_from_background(message));
                                                match r {
                                                    Ok(_) => {}
                                                    Err(e) => {
                                                        let lvl = ::log::Level::Error;
                                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                                            && lvl <= ::log::max_level()
                                                        {
                                                            ::log::__private_api_log(
                                                                format_args!(
                                                                    "Failed to send Kafka message to main thread once received with error: {0}!",
                                                                    e
                                                                ),
                                                                lvl,
                                                                &(
                                                                    "charcoal::background::processor",
                                                                    "charcoal::background::processor",
                                                                    "src/background/processor.rs",
                                                                    88u32,
                                                                ),
                                                                ::log::__private_api::Option::None,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                            None => {
                                                {
                                                    let lvl = ::log::Level::Error;
                                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                                        && lvl <= ::log::max_level()
                                                    {
                                                        ::log::__private_api_log(
                                                            format_args!("Failed to send Response from BG Thread!"),
                                                            lvl,
                                                            &(
                                                                "charcoal::background::processor",
                                                                "charcoal::background::processor",
                                                                "src/background/processor.rs",
                                                                93u32,
                                                            ),
                                                            ::log::__private_api::Option::None,
                                                        );
                                                    }
                                                };
                                            }
                                        }
                                    }
                                    Message::ExternalMetadataResult(metadata) => {
                                        let mut tx = guild_id_to_tx.get_mut(&metadata.guild_id);
                                        match tx {
                                            Some(tx) => {
                                                let r = tx.send(IPCData::new_from_background(message));
                                                match r {
                                                    Ok(_) => {}
                                                    Err(e) => {
                                                        let lvl = ::log::Level::Error;
                                                        if lvl <= ::log::STATIC_MAX_LEVEL
                                                            && lvl <= ::log::max_level()
                                                        {
                                                            ::log::__private_api_log(
                                                                format_args!(
                                                                    "Failed to send Kafka message to main thread once received with error: {0}!",
                                                                    e
                                                                ),
                                                                lvl,
                                                                &(
                                                                    "charcoal::background::processor",
                                                                    "charcoal::background::processor",
                                                                    "src/background/processor.rs",
                                                                    106u32,
                                                                ),
                                                                ::log::__private_api::Option::None,
                                                            );
                                                        }
                                                    }
                                                }
                                            }
                                            None => {
                                                {
                                                    let lvl = ::log::Level::Error;
                                                    if lvl <= ::log::STATIC_MAX_LEVEL
                                                        && lvl <= ::log::max_level()
                                                    {
                                                        ::log::__private_api_log(
                                                            format_args!("Failed to send Response from BG Thread!"),
                                                            lvl,
                                                            &(
                                                                "charcoal::background::processor",
                                                                "charcoal::background::processor",
                                                                "src/background/processor.rs",
                                                                111u32,
                                                            ),
                                                            ::log::__private_api::Option::None,
                                                        );
                                                    }
                                                };
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            Err(e) => {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api_log(
                                        format_args!("{0} - Failed to parse message", e),
                                        lvl,
                                        &(
                                            "charcoal::background::processor",
                                            "charcoal::background::processor",
                                            "src/background/processor.rs",
                                            119u32,
                                        ),
                                        ::log::__private_api::Option::None,
                                    );
                                }
                            }
                        }
                    }
                    let _ = consumer.consume_messageset(ms);
                }
                consumer.commit_consumed().unwrap();
                let rx_data = rx.try_recv();
                match rx_data {
                    Ok(d) => {
                        match d {
                            IPCData::FromMain(m) => {
                                guild_id_to_tx.insert(m.guild_id, m.response_tx);
                                send_message(&m.message, "communication", &mut producer);
                            }
                            _ => {}
                        }
                    }
                    Err(e) => {
                        if e.to_string() == "channel empty" {
                            {
                                let lvl = ::log::Level::Debug;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api_log(
                                        format_args!("Channel empty!"),
                                        lvl,
                                        &(
                                            "charcoal::background::processor",
                                            "charcoal::background::processor",
                                            "src/background/processor.rs",
                                            140u32,
                                        ),
                                        ::log::__private_api::Option::None,
                                    );
                                }
                            };
                        } else {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api_log(
                                        format_args!("{0}", e),
                                        lvl,
                                        &(
                                            "charcoal::background::processor",
                                            "charcoal::background::processor",
                                            "src/background/processor.rs",
                                            142u32,
                                        ),
                                        ::log::__private_api::Option::None,
                                    );
                                }
                            };
                        }
                    }
                }
            }
        }
    }
}
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub(crate) struct PRODUCER {
    __private_field: (),
}
#[doc(hidden)]
pub(crate) static PRODUCER: PRODUCER = PRODUCER { __private_field: () };
impl ::lazy_static::__Deref for PRODUCER {
    type Target = Mutex<Option<Producer>>;
    fn deref(&self) -> &Mutex<Option<Producer>> {
        #[inline(always)]
        fn __static_ref_initialize() -> Mutex<Option<Producer>> {
            Mutex::new(None)
        }
        #[inline(always)]
        fn __stability() -> &'static Mutex<Option<Producer>> {
            static LAZY: ::lazy_static::lazy::Lazy<Mutex<Option<Producer>>> = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for PRODUCER {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub(crate) struct CONSUMER {
    __private_field: (),
}
#[doc(hidden)]
pub(crate) static CONSUMER: CONSUMER = CONSUMER { __private_field: () };
impl ::lazy_static::__Deref for CONSUMER {
    type Target = Mutex<Option<Consumer>>;
    fn deref(&self) -> &Mutex<Option<Consumer>> {
        #[inline(always)]
        fn __static_ref_initialize() -> Mutex<Option<Consumer>> {
            Mutex::new(None)
        }
        #[inline(always)]
        fn __stability() -> &'static Mutex<Option<Consumer>> {
            static LAZY: ::lazy_static::lazy::Lazy<Mutex<Option<Consumer>>> = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for CONSUMER {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub(crate) struct TX {
    __private_field: (),
}
#[doc(hidden)]
pub(crate) static TX: TX = TX { __private_field: () };
impl ::lazy_static::__Deref for TX {
    type Target = Mutex<Option<Sender<String>>>;
    fn deref(&self) -> &Mutex<Option<Sender<String>>> {
        #[inline(always)]
        fn __static_ref_initialize() -> Mutex<Option<Sender<String>>> {
            Mutex::new(None)
        }
        #[inline(always)]
        fn __stability() -> &'static Mutex<Option<Sender<String>>> {
            static LAZY: ::lazy_static::lazy::Lazy<Mutex<Option<Sender<String>>>> = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for TX {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
pub(crate) struct RX {
    __private_field: (),
}
#[doc(hidden)]
pub(crate) static RX: RX = RX { __private_field: () };
impl ::lazy_static::__Deref for RX {
    type Target = Mutex<Option<Receiver<String>>>;
    fn deref(&self) -> &Mutex<Option<Receiver<String>>> {
        #[inline(always)]
        fn __static_ref_initialize() -> Mutex<Option<Receiver<String>>> {
            Mutex::new(None)
        }
        #[inline(always)]
        fn __stability() -> &'static Mutex<Option<Receiver<String>>> {
            static LAZY: ::lazy_static::lazy::Lazy<Mutex<Option<Receiver<String>>>> = ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for RX {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}
/// Represents an instance in a voice channel
pub struct PlayerObject {
    worker_id: Option<String>,
    job_id: Option<String>,
    guild_id: String,
    tx: Arc<Sender<IPCData>>,
    rx: Receiver<IPCData>,
    bg_com_tx: Sender<IPCData>,
}
impl PlayerObject {
    /// Creates a new Player Object that can then be joined to channel and used to playback audio
    pub async fn new(guild_id: String, com_tx: Sender<IPCData>) -> Self {
        let (tx, mut rx) = broadcast::channel(16);
        PlayerObject {
            worker_id: None,
            job_id: None,
            guild_id,
            tx: Arc::new(tx),
            rx: rx,
            bg_com_tx: com_tx,
        }
    }
}
/// Stores Charcoal instance
pub struct Charcoal {
    pub players: HashMap<String, PlayerObject>,
    pub tx: Sender<IPCData>,
    pub rx: Receiver<IPCData>,
}
impl Charcoal {
    pub fn get_player(&mut self, guild_id: &String) -> Option<&mut PlayerObject> {
        return self.players.get_mut(guild_id);
    }
}
/// Stores SSL Config for Kafka
pub struct SSLConfig {
    /// Path to the SSL key file
    pub ssl_key: String,
    /// Path to the SSL CA file
    pub ssl_ca: String,
    /// Path to the SSL cert file
    pub ssl_cert: String,
}
/// Configuration for charcoal
pub struct CharcoalConfig {
    /// Configure SSl for kafka. If left as None no SSL is configured
    pub ssl: Option<SSLConfig>,
    /// Kafka topic to connect to. This should be the same one the hearth server(s) are on.
    pub kafka_topic: String,
}
/// Initializes Charcoal Instance
pub async fn init_charcoal(
    broker: String,
    config: CharcoalConfig,
) -> Arc<Mutex<Charcoal>> {
    let brokers = <[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([broker]));
    let consumer = Consumer::from_client(initialize_client(&brokers, &config))
        .with_topic(config.kafka_topic.clone())
        .create()
        .unwrap();
    let producer: Producer = initialize_producer(initialize_client(&brokers, &config));
    let (tx, mut rx) = broadcast::channel(16);
    let sub_tx = tx.clone();
    let global_rx = tx.subscribe();
    tokio::task::spawn(async move {
        init_processor(rx, sub_tx, consumer, producer).await;
    });
    Arc::new(
        Mutex::new(Charcoal {
            players: HashMap::new(),
            tx,
            rx: global_rx,
        }),
    )
}
